# Validation & Balance System

## Purpose

Every bot generated by the LLM passes through validation before entering the arena. The validator catches physics-breaking configs, auto-corrects minor issues, and enforces game balance. This document defines all constraint rules and the auto-correction pipeline.

---

## 1. Validation Pipeline

```
LLM Output (JSON)
      │
      ▼
┌─────────────┐
│ Parse JSON   │ → Reject if malformed
└──────┬──────┘
       ▼
┌─────────────┐
│ Type Check   │ → Reject if missing required fields
└──────┬──────┘
       ▼
┌─────────────┐
│ Range Clamp  │ → Auto-correct out-of-range values
└──────┬──────┘
       ▼
┌─────────────┐
│ Weight Check │ → Auto-correct if over budget
└──────┬──────┘
       ▼
┌─────────────┐
│ Compat Check │ → Apply penalties for poor shape-weapon combos
└──────┬──────┘
       ▼
┌─────────────┐
│ Archetype    │ → Auto-fill missing archetype-specific config
│ Validation   │
└──────┬──────┘
       ▼
┌─────────────┐
│ Behavior     │ → Validate behavior code syntax + API calls
│ Validation   │
└──────┬──────┘
       ▼
  Valid BotDefinition
```

---

## 2. Range Constraints

All numeric values are clamped to safe ranges:

| Field | Min | Max | Default | Notes |
|-------|-----|-----|---------|-------|
| `size` | 1 | 5 | 3 | Chassis size |
| `speed` | 1 | 10 | 5 | Base speed |
| `armor` | 1 | 10 | 5 | Damage reduction |
| `weapon.damage` | 1 | 10 | 5 | Base weapon damage |
| `weapon.cooldown` | 200 | 2000 | 800 | ms between attacks |
| `weapon.range` | 20 | 250 | 50 | px reach |
| `attackEffect.intensity` | 1 | 5 | 3 | Visual intensity |
| `attackEffect.trailLength` | 1 | 5 | 2 | Trail copies |

### Spinner-Specific

| Field | Min | Max | Default |
|-------|-----|-----|---------|
| `spinner.targetSpeed` | 1 | 10 | 7 |
| `spinner.spinUpRate` | 0.1 | 1.0 | 0.5 |
| `spinner.bladeRadius` | 10 | 40 | 25 |
| `spinner.bladeCount` | 1 | 6 | 3 |

### Spray-Specific

| Field | Min | Max | Default |
|-------|-----|-----|---------|
| `continuous.width` | 10 | 90 | 40 |
| `continuous.duration` | 500 | 3000 | 1500 |
| `continuous.particleRate` | 2 | 15 | 8 |
| `continuous.dotDuration` | 0 | 5000 | 2000 |
| `continuous.dotTickDamage` | 0 | 0.5 | 0.15 |

### Projectile-Specific

| Field | Min | Max | Default |
|-------|-----|-----|---------|
| `projectile.speed` | 2 | 12 | 6 |
| `projectile.size` | 2 | 8 | 4 |
| `projectile.lifetime` | 20 | 90 | 60 |
| `projectile.explosionRadius` | 0 | 60 | 0 |

### Reach-Specific

| Field | Min | Max | Default |
|-------|-----|-----|---------|
| Per segment `length` | 20 | 60 | 50 |
| Per segment `width` | 2 | 12 | 6 |
| Total segment count | 1 | 4 | 2 |
| Total reach | 20 | 180 | 100 |
| `tipCollider.radius` | 5 | 20 | 10 |

---

## 3. Weight Budget Validation

```typescript
function validateWeightBudget(def: BotDefinition): ValidationResult {
  const budget = calculateWeightBudget(def);
  
  if (budget.remaining >= 0) {
    return { valid: true, budget };
  }
  
  // Over budget — auto-correct
  const corrections: string[] = [];
  const corrected = { ...def };
  let overBy = -budget.remaining;
  
  // Priority order: reduce speed first, then armor, then damage
  while (overBy > 0) {
    if (corrected.speed > 1) {
      corrected.speed--;
      overBy -= 2; // speed costs 2 WU per point
      corrections.push(`Reduced speed to ${corrected.speed}`);
    } else if (corrected.armor > 1) {
      corrected.armor--;
      overBy -= 4; // armor costs 4 WU per point
      corrections.push(`Reduced armor to ${corrected.armor}`);
    } else if (corrected.weapon.damage > 1) {
      corrected.weapon.damage--;
      overBy -= 2; // damage costs 2 WU per point
      corrections.push(`Reduced weapon damage to ${corrected.weapon.damage}`);
    } else {
      break; // Can't reduce further
    }
  }
  
  return {
    valid: true,
    corrected,
    corrections,
    warning: `Bot was ${-budget.remaining} WU over budget. Applied: ${corrections.join(', ')}`
  };
}
```

---

## 4. Shape-Weapon Compatibility Validation

```typescript
type CompatLevel = 'best' | 'good' | 'poor';

const COMPATIBILITY: Record<BodyShape, Record<WeaponType, CompatLevel>> = {
  circle:    { spinner: 'best', saw: 'best', flamethrower: 'good', flipper: 'good', hammer: 'poor', lance: 'poor' },
  rectangle: { hammer: 'best', lance: 'best', flipper: 'best', flamethrower: 'good', saw: 'good', spinner: 'good' },
  triangle:  { lance: 'best', flipper: 'best', hammer: 'good', saw: 'good', spinner: 'poor', flamethrower: 'good' },
  pentagon:  { hammer: 'best', saw: 'best', spinner: 'good', flamethrower: 'good', lance: 'poor', flipper: 'good' },
  hexagon:   { spinner: 'best', flamethrower: 'best', hammer: 'good', saw: 'good', lance: 'poor', flipper: 'good' },
};

function applyCompatibilityModifiers(def: BotDefinition): BotDefinition {
  const compat = COMPATIBILITY[def.shape][def.weapon.type];
  const modified = { ...def, weapon: { ...def.weapon } };
  
  switch (compat) {
    case 'best':
      modified.weapon.cooldown = Math.round(modified.weapon.cooldown * 0.9); // 10% faster
      break;
    case 'good':
      // No modification
      break;
    case 'poor':
      modified.weapon.damage = Math.round(modified.weapon.damage * 0.85); // 15% less damage
      modified.weapon.cooldown = Math.round(modified.weapon.cooldown * 1.2); // 20% slower
      break;
  }
  
  return modified;
}
```

---

## 5. Archetype-Specific Validation

Ensure the LLM included the right sub-config for the weapon type:

```typescript
function validateArchetypeConfig(def: BotDefinition): BotDefinition {
  const weapon = def.weapon;
  const corrected = { ...def, weapon: { ...weapon } };
  
  // Spray weapons MUST have continuous config
  if (['flamethrower'].includes(weapon.type) && !weapon.continuous) {
    corrected.weapon.mode = 'continuous';
    corrected.weapon.continuous = {
      shape: 'cone',
      width: 40,
      duration: 2000,
      particleRate: 8,
      dotDuration: 2000,
      dotTickDamage: 0.15,
    };
  }
  
  // Spinners MUST have spinner config
  if (['spinner', 'saw'].includes(weapon.type) && !weapon.spinner) {
    corrected.weapon.spinner = {
      targetSpeed: 8,
      spinUpRate: 0.7,
      bladeRadius: 25,
      bladeCount: weapon.type === 'saw' ? 1 : 4,
    };
  }
  
  // Long-range weapons with range > 100 SHOULD have segments
  if (['lance'].includes(weapon.type) && weapon.range > 100 && !weapon.segments) {
    const segCount = Math.min(Math.ceil(weapon.range / 60), 4);
    const segLength = Math.floor(weapon.range / segCount);
    corrected.weapon.segments = Array.from({ length: segCount }, (_, i) => ({
      length: segLength,
      width: 8 - i * 2,
      angleLimit: { min: -45 + i * 15, max: 90 - i * 20 },
    }));
    corrected.weapon.tipCollider = { type: 'circle', radius: 10 };
  }
  
  return corrected;
}
```

---

## 6. Behavior Code Validation

```typescript
function validateBehaviorCode(code: string, weaponType: WeaponType): ValidationResult {
  const errors: string[] = [];
  
  // Syntax check
  try {
    new Function('api', 'tick', code);
  } catch (e) {
    return { valid: false, error: `Behavior syntax error: ${e.message}` };
  }
  
  // Check for required API calls based on weapon type
  if (['flamethrower'].includes(weaponType)) {
    if (!code.includes('startSpraying') && !code.includes('stopSpraying')) {
      errors.push('Spray weapon behavior must call api.startSpraying()/api.stopSpraying()');
    }
  }
  
  if (['spinner', 'saw'].includes(weaponType)) {
    if (!code.includes('startSpinning')) {
      errors.push('Spinner weapon behavior should call api.startSpinning()');
    }
  }
  
  // Check for common mistakes
  if (code.includes('while') || code.includes('for')) {
    if (!code.includes('break') && code.length > 500) {
      errors.push('Warning: loops in behavior code risk infinite execution. Add break conditions.');
    }
  }
  
  // Length cap
  if (code.length > 2000) {
    errors.push('Behavior code too long (max 2000 chars). Simplify logic.');
  }
  
  return {
    valid: errors.length === 0,
    warnings: errors,
  };
}
```

---

## 7. Balance Scoring

After validation, calculate a **balance score** to detect outlier bots:

```typescript
interface BalanceScore {
  offensiveScore: number;  // 0-100
  defensiveScore: number;  // 0-100
  mobilityScore: number;   // 0-100
  totalScore: number;      // 0-100 (should be 40-70 for balanced bots)
}

function calculateBalanceScore(def: BotDefinition): BalanceScore {
  const offensive = (def.weapon.damage * 10) + 
                    (100 - def.weapon.cooldown / 20) +
                    (def.weapon.range / 2.5);
  
  const defensive = (def.armor * 10) + 
                    (def.size * 5);
  
  const mobility = (def.speed * 10) + 
                   (def.shape === 'circle' ? 10 : 0);
  
  const total = (offensive + defensive + mobility) / 3;
  
  return {
    offensiveScore: Math.min(100, offensive),
    defensiveScore: Math.min(100, defensive),
    mobilityScore: Math.min(100, mobility),
    totalScore: Math.min(100, total),
  };
}
```

### Balance Warnings

| Total Score | Assessment | Action |
|-------------|-----------|--------|
| 0-30 | **Underpowered** | Warn: "This bot may be too weak to compete." |
| 31-40 | **Specialized** | OK — niche build, might work |
| 41-65 | **Balanced** | ✅ Ideal range |
| 66-80 | **Strong** | OK — powerful but beatable |
| 81-100 | **Overpowered** | Warn: "This bot may need stat reductions for fair play." |

---

## 8. Validation Report

After all checks, produce a human-readable report:

```typescript
function generateValidationReport(
  original: BotDefinition,
  validated: BotDefinition,
  corrections: string[],
  balance: BalanceScore
): string {
  const lines: string[] = [];
  
  lines.push(`## Validation Report: ${validated.name}`);
  lines.push('');
  
  if (corrections.length === 0) {
    lines.push('✅ All checks passed. No corrections needed.');
  } else {
    lines.push(`⚠️ ${corrections.length} auto-correction(s) applied:`);
    corrections.forEach(c => lines.push(`  - ${c}`));
  }
  
  lines.push('');
  lines.push('### Balance Score');
  lines.push(`| Category | Score |`);
  lines.push(`|----------|-------|`);
  lines.push(`| Offensive | ${balance.offensiveScore}/100 |`);
  lines.push(`| Defensive | ${balance.defensiveScore}/100 |`);
  lines.push(`| Mobility | ${balance.mobilityScore}/100 |`);
  lines.push(`| **Total** | **${balance.totalScore}/100** |`);
  
  return lines.join('\n');
}
```

---

## Summary

| Validation Step | What It Checks | Auto-Corrects? |
|----------------|---------------|----------------|
| Parse | Valid JSON | ❌ Reject |
| Type Check | Required fields exist | ❌ Reject |
| Range Clamp | All values in safe ranges | ✅ Clamp |
| Weight Budget | Total WU ≤ 100 | ✅ Reduce stats |
| Compatibility | Shape-weapon fit | ✅ Apply penalties |
| Archetype Config | Sub-config present for weapon type | ✅ Fill defaults |
| Behavior | Syntax valid, correct API calls | ⚠️ Warn |
| Balance | Not too weak or too strong | ⚠️ Warn |
